<#@ template language="C#" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Net" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ output extension=".cs" #>
<# List<(string name, string value)> headerNames = new List<(string name, string value)>()
{
    ("HttpConstants.HttpHeaders.ActivityId", "x-ms-activity-id"),
    ("HttpConstants.HttpHeaders.LastStateChangeUtc", "x-ms-last-state-change-utc"),
    ("HttpConstants.HttpHeaders.ContinuationToken", "x-ms-continuationtoken"),
    ("HttpConstants.HttpHeaders.ETag", "etag"),
    ("HttpConstants.HttpHeaders.RetryAfterInMilliseconds", "x-ms-retry-after-ms"),
    ("HttpConstants.HttpHeaders.IndexingDirective", "x-ms-indexing-directive"),
    ("HttpConstants.HttpHeaders.MaxResourceQuota", "x-ms-resource-quota"),
    ("HttpConstants.HttpHeaders.CurrentResourceQuotaUsage", "x-ms-resource-usage"),
    ("HttpConstants.HttpHeaders.SchemaVersion", "x-ms-schemaversion"),
    ("WFConstants.BackendHeaders.CollectionPartitionIndex", "collection-partition-index"),
    ("WFConstants.BackendHeaders.CollectionServiceIndex", "collection-service-index"),
    ("WFConstants.BackendHeaders.LSN", "lsn"),
    ("HttpConstants.HttpHeaders.ItemCount", "x-ms-item-count"),
    ("HttpConstants.HttpHeaders.RequestCharge", "x-ms-request-charge"),
    ("HttpConstants.HttpHeaders.OwnerFullName", "x-ms-alt-content-path"),
    ("HttpConstants.HttpHeaders.OwnerId", "x-ms-content-path"),
    ("WFConstants.BackendHeaders.DatabaseAccountId", "x-ms-database-account-id"),
    ("WFConstants.BackendHeaders.QuorumAckedLSN", "x-ms-quorum-acked-lsn"),
    ("HttpConstants.HttpHeaders.RequestValidationFailure", "x-ms-request-validation-failure"),
    ("WFConstants.BackendHeaders.SubStatus", "x-ms-substatus"),
    ("HttpConstants.HttpHeaders.CollectionIndexTransformationProgress", "x-ms-documentdb-collection-index-transformation-progress"),
    ("WFConstants.BackendHeaders.CurrentWriteQuorum", "x-ms-current-write-quorum"),
    ("WFConstants.BackendHeaders.CurrentReplicaSetSize", "x-ms-current-replica-set-size"),
    ("HttpConstants.HttpHeaders.CollectionLazyIndexingProgress", "x-ms-documentdb-collection-lazy-indexing-progress"),
    ("HttpConstants.HttpHeaders.PartitionKeyRangeId", "x-ms-documentdb-partitionkeyrangeid"),
    ("HttpConstants.HttpHeaders.LogResults", "x-ms-documentdb-script-log-results"),
    ("HttpConstants.HttpHeaders.XPRole", "x-ms-xp-role"),
    ("HttpConstants.HttpHeaders.IsRUPerMinuteUsed", "x-ms-documentdb-is-ru-per-minute-used"),
    ("HttpConstants.HttpHeaders.QueryMetrics", "x-ms-documentdb-query-metrics"),
    ("HttpConstants.HttpHeaders.QueryExecutionInfo", "x-ms-cosmos-query-execution-info"),
    ("HttpConstants.HttpHeaders.IndexUtilization", "x-ms-cosmos-index-utilization"),
    ("WFConstants.BackendHeaders.GlobalCommittedLSN", "x-ms-global-Committed-lsn"),
    ("WFConstants.BackendHeaders.NumberOfReadRegions", "x-ms-number-of-read-regions"),
    ("WFConstants.BackendHeaders.OfferReplacePending", "x-ms-offer-replace-pending"),
    ("WFConstants.BackendHeaders.ItemLSN", "x-ms-item-lsn"),
    ("WFConstants.BackendHeaders.RestoreState", "x-ms-restore-state"),
    ("WFConstants.BackendHeaders.CollectionSecurityIdentifier", "x-ms-collection-security-identifier"),
    ("HttpConstants.HttpHeaders.TransportRequestID", "x-ms-transport-request-id"),
    ("WFConstants.BackendHeaders.ShareThroughput", "x-ms-share-throughput"),
    ("HttpConstants.HttpHeaders.DisableRntbdChannel", "x-ms-disable-rntbd-channel"),
    ("HttpConstants.HttpHeaders.XDate", "x-ms-date"),
    ("WFConstants.BackendHeaders.LocalLSN", "x-ms-cosmos-llsn"),
    ("WFConstants.BackendHeaders.QuorumAckedLocalLSN", "x-ms-cosmos-quorum-acked-llsn"),
    ("WFConstants.BackendHeaders.ItemLocalLSN", "x-ms-cosmos-item-llsn"),
    ("WFConstants.BackendHeaders.HasTentativeWrites", "x-ms-cosmosdb-has-tentative-writes"),
    ("HttpConstants.HttpHeaders.SessionToken", "x-ms-session-token"),
    ("WFConstants.BackendHeaders.ReplicatorLSNToGLSNDelta", "x-ms-cosmos-replicator-glsn-delta"),
    ("WFConstants.BackendHeaders.ReplicatorLSNToLLSNDelta", "x-ms-cosmos-replicator-llsn-delta"),
    ("WFConstants.BackendHeaders.VectorClockLocalProgress", "x-ms-cosmos-vectorclock-local-progress"),
    ("WFConstants.BackendHeaders.MinimumRUsForOffer", "x-ms-cosmos-min-throughput"),
    ("WFConstants.BackendHeaders.XPConfigurationSessionsCount", "x-ms-cosmos-xpconfiguration-sessions-count"),
    ("WFConstants.BackendHeaders.UnflushedMergLogEntryCount", "x-ms-cosmos-internal-unflushed-merge-log-entry-count"),
    ("WFConstants.BackendHeaders.ResourceId", "x-docdb-resource-id"),
    ("WFConstants.BackendHeaders.TimeToLiveInSeconds", "x-ms-time-to-live-in-seconds"),
    ("WFConstants.BackendHeaders.ReplicaStatusRevoked", "x-ms-cosmos-is-replica-status-revoked"),
    ("WFConstants.BackendHeaders.SoftMaxAllowedThroughput", "x-ms-cosmos-offer-max-allowed-throughput"),
    ("HttpConstants.HttpHeaders.BackendRequestDurationMilliseconds", "x-ms-request-duration-ms"),
}; #>
//------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------

// This is auto-generated code.

namespace Microsoft.Azure.Cosmos
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.Linq;
    using Microsoft.Azure.Documents;
    using Microsoft.Azure.Documents.Collections;

    internal class OptimizedResponseHeaders : INameValueCollection
    {
        private readonly Lazy<Dictionary<string, string>> lazyNotCommonHeaders;

<#  List<string> sortedHeaderPropertyNames = headerNames.Select(x => x.name.Split('.').Last()).OrderBy(x => x).ToList();
    foreach(string headerName in sortedHeaderPropertyNames) { #>
        public string <#= headerName #> { get; set; }
<# } #>

        public OptimizedResponseHeaders()
            : this(new Lazy<Dictionary<string, string>>(() => new Dictionary<string, string>()))
        {
        }

        private OptimizedResponseHeaders(Lazy<Dictionary<string, string>> notCommonHeaders)
        {
            this.lazyNotCommonHeaders = notCommonHeaders ?? throw new ArgumentNullException(nameof(notCommonHeaders));
        }

        public string this[string key] 
        { 
            get => this.Get(key); 
            set => this.Set(key, value);
        }

        public void Add(string key, string value)
        {
            this.Set(key, value);
        }

        public void Add(INameValueCollection collection)
        {
            foreach(string key in collection.Keys())
            {
                this.Set(key, collection[key]);
            }
        }

        public string[] AllKeys()
        {
            return this.Keys().ToArray();
        }

        public void Clear()
        {
            if (this.lazyNotCommonHeaders.IsValueCreated)
            {
                this.lazyNotCommonHeaders.Value.Clear();
            }

<#      foreach (string name in sortedHeaderPropertyNames) { #>
            this.<#= name #> = null;
<#      } #>

        }

        public INameValueCollection Clone()
        {
            Lazy<Dictionary<string, string>> cloneNotCommonHeaders = new Lazy<Dictionary<string, string>>(() => new Dictionary<string, string>());
            if (this.lazyNotCommonHeaders.IsValueCreated)
            {
                foreach (KeyValuePair<string, string> notCommonHeader in this.lazyNotCommonHeaders.Value)
                {
                    cloneNotCommonHeaders.Value[notCommonHeader.Key] = notCommonHeader.Value;
                }
            }

            OptimizedResponseHeaders cloneHeaders = new OptimizedResponseHeaders(cloneNotCommonHeaders)
            {
<#            foreach (string name in sortedHeaderPropertyNames) { #>
                <#= name #> = this.<#= name #>,
<#      } #>
            };

            return cloneHeaders;
        }

        public int Count()
        {
            return this.Keys().Count();
        }

        public IEnumerator GetEnumerator()
        {
            return this.Keys().GetEnumerator();
        }

        public string[] GetValues(string key)
        {
            string value = this.Get(key);
            if(value != null){
                return new string[] { value };
            }
            
            return null;
        }

        public IEnumerable<string> Keys()
        {
<#      foreach (string name in sortedHeaderPropertyNames) { #>
                if (this.<#= name #> != null)
                {
                    yield return this.<#= name #>;
                }
<#      } #>
        }

        public NameValueCollection ToNameValueCollection()
        {
            throw new NotImplementedException();
        }

        public void Remove(string key)
        {
            this.Set(key, null);
        }

        public string Get(string key)
        {
            switch (key.Length)
            {
<#      IEnumerable<IGrouping<int, (string name, string value)>> getGroupByLength = headerNames.GroupBy(x => x.value.Length).OrderBy(x => x.Key);
        foreach(IGrouping<int, (string name, string value)> group in getGroupByLength) { #>
                case <#= group.Key #>:
<#      foreach((string name, string value) in group) { #>
                    if (object.ReferenceEquals(<#= name #>, key))
                    {
                        return this.<#= name.Split('.').Last() #>;
                    }
                
<#      } #>
<#      foreach((string name, string value) in group) { #>
                    if (string.Equals(<#= name #>, key, StringComparison.OrdinalIgnoreCase))
                    {
                        return this.<#= name.Split('.').Last() #>;
                    }
                
<#      } #>
                    break;
<#     } #>
                default:
                    break;
            }

            if(this.lazyNotCommonHeaders.IsValueCreated)
            {
                return this.lazyNotCommonHeaders.Value[key];
            }
            
            return null;
        }

        public void Set(string key, string value)
        {
            switch (key.Length)
            {
<#      IEnumerable<IGrouping<int, (string name, string value)>> groupByLength = headerNames.GroupBy(x => x.value.Length).OrderBy(x => x.Key);
        foreach(IGrouping<int, (string name, string value)> group in groupByLength) { #>
                case <#= group.Key #>:
<#      foreach((string name, string value) in group) { #>
                    if (object.ReferenceEquals(<#= name #>, key))
                    {
                        this.<#= name.Split('.').Last() #> = value;
                        return;
                    }
                
<#      } #>
<#      foreach((string name, string value) in group) { #>
                    if (string.Equals(<#= name #>, key, StringComparison.OrdinalIgnoreCase))
                    {
                        this.<#= name.Split('.').Last() #> = value;
                        return;
                    }
                
<#      } #>
                    break;
<#      } #>
                default:
                    break;
            }

            this.lazyNotCommonHeaders.Value[key] = value;
        }
    }
}